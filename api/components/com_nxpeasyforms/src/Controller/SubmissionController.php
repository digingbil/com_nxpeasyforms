<?php
/**
 * @package     NXP Easy Forms
 * @subpackage  com_nxpeasyforms
 * @copyright   Copyright (C) 2024-2025 nexusplugins.com. All rights reserved.
 * @license     GNU General Public License version 3 or later; see LICENSE.txt
 */
declare(strict_types=1);

namespace Joomla\Component\Nxpeasyforms\Api\Controller;

// phpcs:disable PSR1.Files.SideEffects
\defined('_JEXEC') or die;
// phpcs:enable PSR1.Files.SideEffects

use Joomla\CMS\Application\CMSWebApplicationInterface;
use Joomla\CMS\Component\ComponentHelper;
use Joomla\CMS\Factory;
use Joomla\CMS\Language\Text;
use Joomla\CMS\MVC\Controller\ApiController;
use Joomla\CMS\MVC\Factory\MVCFactoryInterface;
use Joomla\CMS\Response\JsonResponse;
use Joomla\CMS\Uri\Uri;
use Joomla\Component\Nxpeasyforms\Administrator\Service\Exception\SubmissionException;
use Joomla\Component\Nxpeasyforms\Administrator\Service\SubmissionService;
use Joomla\Input\Input;

use function explode;
use function filter_var;
use function is_array;
use function parse_url;
use function trim;

/**
 * Public-facing controller for processing form submissions.
 */
final class SubmissionController extends ApiController
{
    protected $contentType = 'submission';

    protected $default_view = 'submission';
    private SubmissionService $service;

    /**
     * SubmissionController constructor.
     *
     * @param   array                         $config    Controller configuration
     * @param   MVCFactoryInterface|null      $factory   MVC factory instance
     * @param   CMSWebApplicationInterface|null  $app    Application instance
     * @param   Input|null                    $input     Input object
     * @param   SubmissionService|null        $service   Submission service
     *
     * @throws  \Exception
     */
    public function __construct(
        $config = [],
        ?MVCFactoryInterface $factory = null,
        ?CMSWebApplicationInterface $app = null,
        ?Input $input = null,
        ?SubmissionService $service = null
    ) {
        parent::__construct($config, $factory, $app, $input);

        // Load language file for user-facing messages
        $language = Factory::getApplication()->getLanguage();
        $language->load('com_nxpeasyforms', JPATH_SITE);

        $container = Factory::getContainer();

        if (!$container->has(SubmissionService::class)) {
            $registerDomainServices = include \JPATH_ADMINISTRATOR . '/components/com_nxpeasyforms/services/domain-services.php';
            $registerDomainServices($container);
        }

        $this->service = $service ?? $container->get(SubmissionService::class);
    }

    public function create(): void
    {
        $data = $this->input->json->getArray();

        if (!is_array($data) || empty($data)) {
            $data = $this->input->post->getArray();
        }

        $formId = (int) ($data['formId'] ?? $data['form_id'] ?? 0);

        if ($formId <= 0) {
            $formId = $this->input->getInt('form_id');
        }

        if ($formId <= 0) {
            $this->respond([
                'success' => false,
                'message' => Text::_('COM_NXPEASYFORMS_ERROR_FORM_NOT_FOUND'),
            ], 404, true);

            return;
        }

        // Validate origin for browser requests to prevent CSRF.
        // API clients (JSON Accept/Content-Type) bypass origin checks.
        if (!$this->isApiClient() && !$this->isValidOrigin()) {
            $this->respond([
                'success' => false,
                'message' => Text::_('COM_NXPEASYFORMS_ERROR_INVALID_ORIGIN'),
            ], 403, true);

            return;
        }

        $files = $this->input->files->getArray();

        // Always skip token validation in API context because:
        // 1. The API runs in a separate Joomla application with its own session
        // 2. CSRF tokens generated by the frontend (site) won't match the API session
        // 3. CSRF protection is handled by origin/referer validation above
        $context = [
            'ip_address' => $this->detectIp(),
            'user_agent' => $this->input->server->getString('HTTP_USER_AGENT', ''),
            'skip_token_validation' => true,
        ];

        try {
            $result = $this->service->handle($formId, $data, $context, $files);
            $this->respond($result);

            return;
        } catch (SubmissionException $exception) {
            $code = $exception->getStatus() ?: 400;
            $this->respond([
                'success' => false,
                'message' => $exception->getMessage(),
                'errors' => $exception->getErrors(),
            ], $code, true);

            return;
        } catch (\Throwable $throwable) {
            Factory::getApplication()->getLogger()->error(
                'NXP Easy Forms submission failed: ' . $throwable->getMessage()
                . ' in ' . $throwable->getFile() . ':' . $throwable->getLine()
            );

            // Return generic error message to avoid leaking internal details
            $this->respond([
                'success' => false,
                'message' => Text::_('COM_NXPEASYFORMS_ERROR_SUBMISSION_FAILED'),
            ], 500, true);

            return;
        }
    }

    /**
     * Check if the request appears to be from an API client (not a browser).
     *
     * @return bool True if the request appears to be from an API client.
     * @since 1.0.6
     */
    private function isApiClient(): bool
    {
        $accept = $this->input->server->getString('HTTP_ACCEPT', '');
        $contentType = $this->input->server->getString('CONTENT_TYPE', '');

        // API clients typically send JSON and don't include text/html in Accept
        return (
            (stripos($accept, 'application/json') !== false && stripos($accept, 'text/html') === false) ||
            stripos($contentType, 'application/json') !== false
        );
    }

    /**
     * Validate the request origin to prevent CSRF attacks.
     *
     * @return bool True if the origin matches the site host; false otherwise.
     * @since 1.0.6
     */
    private function isValidOrigin(): bool
    {
        $origin = $this->input->server->getString('HTTP_ORIGIN', '');
        $referer = $this->input->server->getString('HTTP_REFERER', '');

        $siteUrl = Uri::root();
        $siteHost = parse_url($siteUrl, PHP_URL_HOST);

        if ($origin !== '') {
            $originHost = parse_url($origin, PHP_URL_HOST);
            return $originHost === $siteHost;
        }

        if ($referer !== '') {
            $refererHost = parse_url($referer, PHP_URL_HOST);
            return $refererHost === $siteHost;
        }

        // No origin or referer â€” fail closed for browser requests.
        // API clients bypass this method entirely via the isApiClient() gate.
        return false;
    }

    /**
     * Detect the client IP address with protection against header spoofing.
     * Only trusts forwarded headers when behind a configured trusted proxy.
     *
     * @return string The detected IP address or empty string.
     */
    private function detectIp(): string
    {
        $server = $this->input->server;

        // Get the direct connection IP first
        $remoteAddr = $server->getString('REMOTE_ADDR', '');

        // Only trust forwarded headers if behind a trusted proxy
        $trustedProxies = $this->getTrustedProxies();

        if (!empty($trustedProxies) && $this->isIpInList($remoteAddr, $trustedProxies)) {
            // We're behind a trusted proxy, check forwarded headers
            $forwardedHeaders = ['HTTP_X_FORWARDED_FOR', 'HTTP_X_REAL_IP', 'HTTP_CLIENT_IP'];

            foreach ($forwardedHeaders as $header) {
                $value = $server->getString($header, '');
                if ($value !== '') {
                    $parts = explode(',', $value);
                    $candidate = trim($parts[0]);

                    // Validate it's a public IP (not private/reserved ranges)
                    if (filter_var($candidate, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
                        return $candidate;
                    }
                }
            }
        }

        // Return direct connection IP
        if (filter_var($remoteAddr, FILTER_VALIDATE_IP)) {
            return $remoteAddr;
        }

        return '';
    }

    /**
     * Get list of trusted proxy IP addresses from component configuration.
     *
     * @return array<string> List of trusted proxy IPs.
     */
    private function getTrustedProxies(): array
    {
        $params = ComponentHelper::getParams('com_nxpeasyforms');
        $proxies = $params->get('trusted_proxies', '');

        if ($proxies === '') {
            return [];
        }

        return array_map('trim', explode(',', $proxies));
    }

    /**
     * Check if an IP address is in the given list (supports CIDR notation).
     *
     * @param string $ip The IP address to check.
     * @param array<string> $list The list of IPs or CIDR ranges.
     *
     * @return bool True if the IP is in the list.
     */
    private function isIpInList(string $ip, array $list): bool
    {
        foreach ($list as $trusted) {
            if ($ip === $trusted) {
                return true;
            }

            // Support CIDR notation
            if (str_contains($trusted, '/')) {
                if ($this->ipInCidr($ip, $trusted)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Check if an IP address is within a CIDR range.
     *
     * @param string $ip The IP address to check.
     * @param string $cidr The CIDR range (e.g., "192.168.1.0/24").
     *
     * @return bool True if the IP is within the CIDR range.
     */
    private function ipInCidr(string $ip, string $cidr): bool
    {
        [$subnet, $bits] = explode('/', $cidr, 2);
        $bits = (int) $bits;

        $ipLong = ip2long($ip);
        $subnetLong = ip2long($subnet);

        if ($ipLong === false || $subnetLong === false) {
            return false;
        }

        $mask = -1 << (32 - $bits);

        return ($ipLong & $mask) === ($subnetLong & $mask);
    }

    /**
     * Writes a JSON response to the API output buffer.
     *
     * @param   array<string, mixed>  $payload  Response payload.
     * @param   int                   $status   HTTP status code.
     * @param   bool                  $error    Flag indicating error state.
     *
     * @return  void
     */
    private function respond(array $payload, int $status = 200, bool $error = false): void
    {
        $response = new JsonResponse($payload, null, $error);
        $this->app->setHeader('status', (string) $status, true);
        $this->app->setHeader('Content-Type', 'application/json; charset=utf-8', true);
        $this->app->sendHeaders();
        echo (string) $response;
        $this->app->close();
    }
}
